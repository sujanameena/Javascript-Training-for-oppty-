JavaScript Callbacks:

A callback function is a function that is passed as an argument to another function and executed later.

* A function can accept another function as a parameter.
* Callbacks allow one function to call another at a later time.
* A callback function can execute after another function has finished.

Example: 

<!-- <script>
    function greet(name, callback) {
      console.log("Hello, " + name);
      callback();
    }

    function sayBye() {
      console.log("Goodbye!"); 
    }

    greet("Ajay", sayBye);
  </script> -->

  Here, sayBye() is passed as a callback to greet(), which executes after the greeting.

  Working of Callbacks in JavaScript:

  JavaScript executes code line by line (synchronously), but sometimes we need to delay execution or wait for a task to complete before running the next function. Callbacks help achieve this by passing a function that is executed later.

  1. Basic idea

  <!-- <script>
    function greet(name) {
      console.log("Hello " + name);
    }

    function processUserInput(callback) {
      const name = "Sujana";
      callback(name); // calling the callback
    }

    processUserInput(greet);
  </script> -->

  1.greet is a callback.
2.processUserInput is a higher‑order function (it receives a function as an argument).
3.When processUserInput runs, it later calls back greet.

2. Callbacks with asynchronous code

JavaScript is single‑threaded, but it can handle async operations (timers, network, file loading, etc.) using callbacks.

<!-- <script>
    console.log("Start");

    setTimeout(function () {
      console.log("Inside timeout (after 2 seconds)");
    }, 2000); // callback runs later

    console.log("End");
  </script> -->

  The callback inside setTimeout is stored and executed later, after 2 seconds, without blocking the rest of the code.

3. Error‑first callbacks (common in Node.js and APIs)------Explain this late

<!-- <script>
    function getData(callback) {
      const error = null;  // or some error object
      const data = { id: 1, name: "sujana" };
      callback(error, data);
    }

    getData(function (err, result) {
      if (err) {
        console.log("Error:", err);
      } else {
        console.log("Result:", result);
      }
    });
  </script> -->

  Convention: callback(error, result)

If error is not null, something went wrong.
If error is null, use result.

4. Callback hell (nested callbacks)------Explain this late

When many async steps depend on each other, callbacks can get deeply nested:

<!-- <script>
    const doStep1 = (callback) => callback("Step 1 result");
    const doStep2 = (input, callback) => callback("Step 2 result");
    const doStep3 = (input, callback) => callback("Step 3 result");

    doStep1(function (result1) {
      doStep2(result1, function (result2) {
        doStep3(result2, function (result3) {
          console.log("All done");
        });
      });
    });
  </script> -->

  This is hard to read and maintain — called callback hell.

  Modern JS uses Promises and async/await to make this cleaner, but under the hood they still rely on the same event loop and callback mechanism.


  Uses of Callbacks in JavaScript
  --------------------------------

  1. Handling Asynchronous Operations

  Callbacks are widely used in

*API requests (fetching data & function)

<!-- <script>
    function getUserData(callback) {
      // https://jsonplaceholder.typicode.com/users/1
      fetch("https://jsonplaceholder.typicode.com/todos/1")
        .then(function (response) {
          return response.json();       // convert JSON
        })
        .then(function (data) {
          callback(null, data);         // success: first arg = null (no error)
        })
        .catch(function (error) {
          callback(error, null);        // error: pass error to callback
        });
    }

    getUserData(function (error, data) {
      if (error) {
        console.log("Error:", error);
      } else {
        console.log("User Data:", data);
      }
    });
  </script> -->

*Reading files (Node.js file system)
*Event listeners (clicks, keyboard inputs)
*Database queries (retrieving data)

2. Callbacks in Functions Handling Operations

Callbacks in functions handling operations means: you write a general function that does some setup/work, and you pass in another function (the callback) to decide what to do with the result.

When a function needs to execute different behaviors based on input, callbacks make the function flexible.

a. Generic operation on two numbers

<!-- <script>
    function doOperation(a, b, callback) {
      const result = callback(a, b);   // callback decides the operation
      console.log("Result:", result);
    }

    function add(x, y)  {
      return x + y;
    }

    function multiply(x, y) {
      return x * y;
    }
  
    doOperation(5, 3, add);       
    doOperation(5, 3, multiply);  
  </script> -->

  b. Processing an array with a callback

  <!-- <script>
    function processArray(arr, callback) {
      const result = [];
      for (let i = 0; i < arr.length; i++) {
        result.push(callback(arr[i]));  // apply callback to each item
      }
      return result;
    }

    const numbers = [1, 2, 3, 4];

    const doubled = processArray(numbers, function (n) {
      return n * 2;
    });

    console.log(doubled); // [2, 4, 6, 8] 
  </script> -->

  c. Validation / success-failure callbacks

  <!-- <script>
    function validateAge(age, onSuccess, onError) {
      if (age >= 18) {
        onSuccess("Access granted");
      } else {
        onError("Access denied");
      }
    }

    validateAge(
      20,
      function (msg) {
        console.log("SUCCESS:", msg);
      },
      function (err) {
        console.log("ERROR:", err);
      }
    );
  </script> -->

  3. Callbacks in Event Listeners

  In event listeners, the callback is the function that runs when the event happens (click, keyup, submit, etc.).

  Basic example (button click):
   <!-- <button id="myBtn">Click me</button>

<script>
  const button = document.getElementById("myBtn");

  // This function is the callback
  function handleClick() {
    console.log("Button was clicked!");
  }

  // We pass the callback to addEventListener
  button.addEventListener("click", handleClick);
</script> -->

With an anonymous callback and event object:

<!-- <button id="myBtn">Click me</button>

 <script>
  const button = document.getElementById("myBtn");

  // This function is the callback
  function handleClick() {
    console.log("Button was clicked!");
  }

  // We pass the callback to addEventListener
  // button.addEventListener("click", handleClick);

  button.addEventListener("click", function (event) {
  //  Logs the mouse click’s horizontal (clientX) and vertical (clientY) positions in the viewport to the browser console for debugging or tracking click locations.
  console.log("Clicked at:", event.clientX, event.clientY);
});
</script>  -->

Keyboard event example:

<!-- <input id="nameInput" placeholder="Type your name" />

  <script>
    const input = document.getElementById("nameInput");

    input.addEventListener("keyup", function (event) {
      console.log("You typed:", event.target.value);
    });
  </script> -->

  4. Callbacks in API Calls (Fetching Data)

  Example:1
  
  <!-- <script>
    function fetchUser(userId, callback) {
  fetch("https://jsonplaceholder.typicode.com/users/" + userId)
    .then(function (response) {
      return response.json();              // parse JSON
    })
    .then(function (data) {
      callback(null, data);                // success → error = null
    })
    .catch(function (error) {
      callback(error, null);               // failure → pass the error
    });
}

// Using the function
fetchUser(1, function (err, user) {
  if (err) {
    console.log("Error while fetching user:", err);
  } else {
    console.log("User data:", user);
    console.log("User name:", user.name);
  }
});
  </script> -->

Problems with Callbacks:

Although callbacks are useful, they have some drawbacks.

1. Callback Hell (Nested Callbacks):

Callback hell happens when you have many asynchronous operations that depend on each other, and you handle them with deeply nested callbacks. This creates the classic “pyramid of doom” and makes code hard to read, debug, and maintain.

When callbacks are nested deeply, the code becomes unreadable and hard to maintain.

Example:1 

 <!-- <script>
   function step1(callback) {
    setTimeout(() => {
        console.log("Step 1 completed");
        callback();
    }, 1000);
}

function step2(callback) {
    setTimeout(() => {
        console.log("Step 2 completed");
        callback();
    }, 1000);
}

function step3(callback) {
    setTimeout(() => {
        console.log("Step 3 completed");
        callback();
    }, 1000);
}

step1(() => {
    step2(() => {
        step3(() => {
            console.log("All steps completed");
        });
    });
});
  </script> -->

  Example:2 (Do not explain this to the students)

  <!-- <!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8" />
  <title>Callback Hell Simple Demo</title>
  <style>
    body {
      font-family: Arial, sans-serif;
      margin: 20px;
    }

    button {
      padding: 8px 16px;
      margin-bottom: 10px;
      cursor: pointer;
    }

    #log {
      border: 1px solid #ccc;
      padding: 10px;
      min-height: 80px;
      background: #f9f9f9;
      white-space: pre-line;
      font-size: 14px;
    }
  </style>
</head>

<body>
  <h1>Callback Hell (Simple Example)</h1>

  <button id="startBtn">Start Process</button>

  <div id="log"></div>

  <script>
    // Get elements
    const logBox = document.getElementById("log");
    const startBtn = document.getElementById("startBtn");

    // Helper to show messages on the page
    function log(message) {
      logBox.textContent += message + "\n";
    }

    // 1. Fake async function: user login
    function login(username, password, callback) {
      setTimeout(() => {
        log("Step 1: User logged in as " + username);
        // Pass null for error, and a fake result object
        callback(null, { userId: 1 });
      }, 500);
    }

    // 2. Fake async function: get user profile
    function getProfile(userId, callback) {
      setTimeout(() => {
        log("Step 2: Got profile for user id " + userId);
        callback(null, { userId: userId, name: "Alice" });
      }, 500);
    }

    // 3. Fake async function: get user notifications
    function getNotifications(userId, callback) {
      setTimeout(() => {
        log("Step 3: Got notifications for user id " + userId);
        callback(null, ["New message", "New friend request"]);
      }, 500);
    }

    // When button is clicked, start the whole flow
    startBtn.addEventListener("click", () => {
      logBox.textContent = ""; // clear old messages

      // Nested callbacks (callback hell)
      login("alice@example.com", "123456", (error1, loginResult) => {
        if (error1) {
          log("Login failed");
          return;
        }

        getProfile(loginResult.userId, (error2, profile) => {
          if (error2) {
            log("Profile fetch failed");
            return;
          }

          getNotifications(profile.userId, (error3, notifications) => {
            if (error3) {
              log("Notifications fetch failed");
              return;
            }

            // Final result
            log("Step 4: All data ready");
            log("Name: " + profile.name);
            log("Notifications: " + notifications.join(", "));
          });
        });
      });
    });
  </script>
</body>
</html> -->

Example:3 

<!-- <script>
    // Example: Online food order with nested callbacks (callback hell)
    // 1) Place order
    function placeOrder(order, callback) {
      setTimeout(() => {
        console.log("Order placed:", order);
        callback(null, { orderId: 101, ...order });
      }, 500);
    }

    // 2) Process payment
    function processPayment(order, callback) {
      setTimeout(() => {
        console.log("Payment done for order:", order.orderId);
        callback(null, { ...order, paymentStatus: "Success" });
      }, 500);
    }

    // 3) Prepare order
    function prepareOrder(order, callback) {
      setTimeout(() => {
        console.log("Order prepared:", order.orderId);
        callback(null, { ...order, status: "Ready for delivery" });
      }, 500);
    }

    // 4) Send notification to user
    function sendNotification(order, callback) {
      setTimeout(() => {
        console.log("Notification sent to user for order:", order.orderId);
        callback(null, "Notification sent successfully");
      }, 500);
    }

    // ---- Using all functions with nested callbacks (callback hell) ----
    const myOrder = { item: "Pizza", quantity: 2 };

    placeOrder(myOrder, (err1, orderResult) => {
      if (err1) {
        console.log("Error placing order");
        return;
      }

      processPayment(orderResult, (err2, paidOrder) => {
        if (err2) {
          console.log("Error in payment");
          return;
        }

        prepareOrder(paidOrder, (err3, preparedOrder) => {
          if (err3) {
            console.log("Error preparing order");
            return;
          }

          sendNotification(preparedOrder, (err4, message) => {
            if (err4) {
              console.log("Error sending notification");
              return;
            }

            console.log("All steps done!");
            console.log("Final order:", preparedOrder);
            console.log("Message:", message);
          });
        });
      });
    });
  </script> -->

  2. Error Handling Issues in Callbacks:

  Error handling issues in callbacks are the problems that arise because each asynchronous callback must manually manage its own errors.

In classic “error‑first” callbacks (err, result) this causes:

* Every callback must remember to check if (err) and handle it.
* It’s easy to forget an if (err) check, so errors get silently ignored.
* Error handling code is duplicated at every nesting level.
* try/catch around async calls cannot catch errors thrown inside later callbacks.
* If a callback is never called, or called twice, errors are lost or handled incorrectly.

Example:1 

<!-- <script>
    function divide(a, b, callback) {
      if (b === 0) {
        callback(new Error("Cannot divide by zero"), null);
      } else {
        callback(null, a / b);
      }
    }

    function result(error, result) {
      if (error) {
        console.log("Error:", error.message);
      } else {
        console.log("Result:", result);
      }
    }

    divide(10, 2, result);
    divide(10, 0, result);
  </script> -->
  
Example:2 

